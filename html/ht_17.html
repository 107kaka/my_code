<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content=
"text/html; charset=us-ascii" />
	
<title>Chapter 8: Advanced Views and URLconfs</title>

<link rel="stylesheet" href="/sitemedia/css/reset-min.css" type="text/css">
<link rel="stylesheet" href="/sitemedia/css/grids-min.css" type="text/css">
<link rel="stylesheet" href="/sitemedia/css/djangobook.css" type="text/css">
<link href="/sitemedia/css/container.css" type="text/css" media="screen" rel="stylesheet">
<link href="/sitemedia/css/tabs.css" type="text/css" media="screen" rel="stylesheet">
<link href="/sitemedia/css/resizable.css" type="text/css" media="screen" rel="stylesheet">
</head>
<body>
<div id="doc" class="yui-t7">
      <div id="hd">
        <h1><a href="/">The Django Book</a></h1>
        <div id="global-nav">
            <a class="about" href="http://new.djangobook.com/about/">About</a>
          |
            <a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>
          |
            <a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>
          |
            <a class="errata" href="http://new.djangobook.com/errata/">Errata</a>
          |
            <a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">
                Buy the print version on Amazon.com</a>
        </div>
        <div class="nav">
            已完成 132段 共有 132段 完成度 100%
        	<a href="/chapter08/ecn/">| 中英文对照</a> |
        	<a href="/chapter08/en/">英文</a> |
        	<a href="/chapter08/">中文</a>
        	<a href="/chapter07/en/">| 上一章</a> |
        	<a href="/">目  录</a> |
        	<a href="/chapter09/en/">下一章 </a> |
        	<a href="/chapter08/translate/">翻译 </a>  |
        </div>
     </div>
<div id="bd">
<div id="yui-main">
  <div class="yui-b">
    <div id="chapter-body">  
    	
    <div class="document" id="chapter-8-advanced-views-and-urlconfs">
<h1 class="cn title" id="cn0">Chapter 8: Advanced Views and URLconfs</h1>
<p class="cn" id="cn1">In Chapter 3, we explained the basics of Django view functions and URLconfs. This chapter goes into
more detail about advanced functionality in those two pieces of the framework.</p>
<div class="section" id="urlconf-tricks">
<span id="cn2"></span><h2 class="cn" id="cn2">URLconf Tricks</h2>
<p class="cn" id="cn3">Theres nothing special about URLconfs like anything else in Django, theyre just Python code. You
can take advantage of this in several ways, as described in the sections that follow.</p>
<div class="section" id="streamlining-function-imports">
<span id="cn4"></span><h3 class="cn" id="cn4">Streamlining Function Imports</h3>
<p class="cn" id="cn5">Consider this URLconf, which builds on the example in Chapter 3:</p>
<pre class="cn literal-block" id="cn6">
from django.conf.urls.defaults import *
from mysite.views import current_datetime, hours_ahead, hours_behind, now_in_chicago, now_in_london

urlpatterns = patterns('',
    (r'^now/$', current_datetime),
    (r'^now/plus(\d{1,2})hours/$', hours_ahead),
    (r'^now/minus(\d{1,2})hours/$', hours_behind),
    (r'^now/in_chicago/$', now_in_chicago),
    (r'^now/in_london/$', now_in_london),
)
</pre>
<p class="cn" id="cn8">As explained in Chapter 3, each entry in the URLconf includes its associated view function, passed
directly as a function object. This means its necessary to import the view functions at the top of
the module.</p>
<p class="cn" id="cn9">But as a Django application grows in complexity, its URLconf grows, too, and keeping those imports
can be tedious to manage. (For each new view function, you have to remember to import it, and the
import statement tends to get overly long if you use this approach.) Its possible to avoid that
tedium by importing the <tt class="docutils literal"><span class="pre">views</span></tt> module itself. This example URLconf is equivalent to the previous
one:</p>
<pre class="cn literal-block" id="cn10">
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^now/$', views.current_datetime),
    (r'^now/plus(\d{1,2})hours/$', views.hours_ahead),
    (r'^now/minus(\d{1,2})hours/$', views.hours_behind),
    (r'^now/in_chicago/$', views.now_in_chicago),
    (r'^now/in_london/$', views.now_in_london),
)
</pre>
<p class="cn" id="cn12">Django offers another way of specifying the view function for a particular pattern in the URLconf:
you can pass a string containing the module name and function name rather than the function object
itself. Continuing the ongoing example:</p>
<pre class="cn literal-block" id="cn13">
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^now/$', 'mysite.views.current_datetime'),
    (r'^now/plus(\d{1,2})hours/$', 'mysite.views.hours_ahead'),
    (r'^now/minus(\d{1,2})hours/$', 'mysite.views.hours_behind'),
    (r'^now/in_chicago/$', 'mysite.views.now_in_chicago'),
    (r'^now/in_london/$', 'mysite.views.now_in_london'),
)
</pre>
<p class="cn" id="cn15">(Note the quotes around the view names. Were using <tt class="docutils literal"><span class="pre">'mysite.views.current_datetime'</span></tt> with quotes
instead of <tt class="docutils literal"><span class="pre">mysite.views.current_datetime</span></tt> .)</p>
<p class="cn" id="cn16">Using this technique, its no longer necessary to import the view functions; Django automatically
imports the appropriate view function the first time its needed, according to the string describing
the name and path of the view function.</p>
<p class="cn" id="cn17">A further shortcut you can take when using the string technique is to factor out a common view
prefix. In our URLconf example, each of the view strings starts with <tt class="docutils literal"><span class="pre">'mysite.views'</span></tt> , which is
redundant to type. We can factor out that common prefix and pass it as the first argument to
<tt class="docutils literal"><span class="pre">patterns()</span></tt> , like this:</p>
<pre class="cn literal-block" id="cn18">
from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
    (r'^now/$', 'current_datetime'),
    (r'^now/plus(\d{1,2})hours/$', 'hours_ahead'),
    (r'^now/minus(\d{1,2})hours/$', 'hours_behind'),
    (r'^now/in_chicago/$', 'now_in_chicago'),
    (r'^now/in_london/$', 'now_in_london'),
)
</pre>
<p class="cn" id="cn20">Note that you dont put a trailing dot (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> ) in the prefix, nor do you put a leading dot in the
view strings. Django puts those in automatically.</p>
<p class="cn" id="cn21">With these two approaches in mind, which is better? It really depends on your personal coding style
and needs.</p>
<p class="cn" id="cn22">Advantages of the string approach are as follows:</p>
<ul class="simple">
<li class="cn" id="cn23"><p class="first cn" id="cn23">Its more compact, because it doesnt require you to import the view functions.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn24"><p class="first cn" id="cn24">It results in more readable and manageable URLconfs if your view functions are spread across
several different Python modules.</p>
</li>
</ul>
<p class="cn" id="cn25">Advantages of the function object approach are as follows:</p>
<ul class="simple">
<li class="cn" id="cn26"><p class="first cn" id="cn26">It allows for easy wrapping of view functions. See the section Wrapping View Functions later in
this chapter.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn27"><p class="first cn" id="cn27">Its more Pythonic that is, its more in line with Python traditions, such as passing functions
as objects.</p>
</li>
</ul>
<p class="cn" id="cn28">Both approaches are valid, and you can even mix them within the same URLconf. The choice is yours.</p>
</div>
<div class="section" id="using-multiple-view-prefixes">
<span id="cn29"></span><h3 class="cn" id="cn29">Using Multiple View Prefixes</h3>
<p class="cn" id="cn30">In practice, if you use the string technique, youll probably end up mixing views to the point where
the views in your URLconf wont have a common prefix. However, you can still take advantage of the
view prefix shortcut to remove duplication. Just add multiple <tt class="docutils literal"><span class="pre">patterns()</span></tt> objects together, like
this:</p>
<p class="cn" id="cn31">Old:</p>
<pre class="cn literal-block" id="cn32">
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^/?$', 'mysite.views.archive_index'),
    (r'^(\d{4})/([a-z]{3})/$', 'mysite.views.archive_month'),
    (r'^tag/(\w+)/$', 'weblog.views.tag'),
)
</pre>
<p class="cn" id="cn34">New:</p>
<pre class="cn literal-block" id="cn35">
from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
    (r'^/?$', 'archive_index'),
    (r'^(\d{4})/([a-z]{3})/$', 'archive_month'),
)

urlpatterns += patterns('weblog.views',
    (r'^tag/(\w+)/$', 'tag'),
)
</pre>
<p class="cn" id="cn37">All the framework cares about is that theres a module-level variable called <tt class="docutils literal"><span class="pre">urlpatterns</span></tt> . This
variable can be constructed dynamically, as we do in this example.</p>
</div>
<div class="section" id="special-casing-urls-in-debug-mode">
<span id="cn38"></span><h3 class="cn" id="cn38">Special-Casing URLs in Debug Mode</h3>
<p class="cn" id="cn39">Speaking of constructing <tt class="docutils literal"><span class="pre">urlpatterns</span></tt> dynamically, you might want to take advantage of this
technique to alter your URLconfs behavior while in Djangos debug mode. To do this, just check the
value of the <tt class="docutils literal"><span class="pre">DEBUG</span></tt> setting at runtime, like so:</p>
<pre class="cn literal-block" id="cn40">
from django.conf.urls.defaults import*
from django.conf import settings

urlpatterns = patterns('',
    (r'^$', 'mysite.views.homepage'),
    (r'^(\d{4})/([a-z]{3})/$', 'mysite.views.archive_month'),
)

if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^debuginfo$', 'mysite.views.debug'),
    )
</pre>
<p class="cn" id="cn42">In this example, the URL <tt class="docutils literal"><span class="pre">/debuginfo/</span></tt> will only be available if your <tt class="docutils literal"><span class="pre">DEBUG</span></tt> setting is set to
<tt class="docutils literal"><span class="pre">True</span></tt> .</p>
</div>
<div class="section" id="using-named-groups">
<span id="cn43"></span><h3 class="cn" id="cn43">Using Named Groups</h3>
<p class="cn" id="cn44">In all of our URLconf examples so far, weve used simple, <em>non-named</em> regular expression groups that
is, we put parentheses around parts of the URL we wanted to capture, and Django passes that
captured text to the view function as a positional argument. In more advanced usage, its possible
to use <em>named</em> regular expression groups to capture URL bits and pass them as <em>keyword</em> arguments
to a view.</p>
<p class="cn" id="cn45">Keyword Arguments vs. Positional Arguments</p>
<p class="cn" id="cn46">A Python function can be called using keyword arguments or positional arguments and, in some cases,
both at the same time. In a keyword argument call, you specify the names of the arguments along
with the values youre passing. In a positional argument call, you simply pass the arguments without
explicitly specifying which argument matches which value; the association is implicit in the
arguments order.</p>
<p class="cn" id="cn47">For example, consider this simple function:</p>
<pre class="cn literal-block" id="cn48">
def sell(item, price, quantity):
    print &quot;Selling %s unit(s) of %s at %s&quot; % (quantity, item, price)
</pre>
<p class="cn" id="cn50">To call it with positional arguments, you specify the arguments in the order in which theyre listed
in the function definition:</p>
<pre class="cn literal-block" id="cn51">
sell('Socks', '$2.50', 6)
</pre>
<p class="cn" id="cn53">To call it with keyword arguments, you specify the names of the arguments along with the values.
The following statements are equivalent:</p>
<pre class="cn literal-block" id="cn54">
sell(item='Socks', price='$2.50', quantity=6)
sell(item='Socks', quantity=6, price='$2.50')
sell(price='$2.50', item='Socks', quantity=6)
sell(price='$2.50', quantity=6, item='Socks')
sell(quantity=6, item='Socks', price='$2.50')
sell(quantity=6, price='$2.50', item='Socks')
</pre>
<p class="cn" id="cn56">Finally, you can mix keyword and positional arguments, as long as all positional arguments are
listed before keyword arguments. The following statements are equivalent to the previous examples:</p>
<pre class="cn literal-block" id="cn57">
sell('Socks', '$2.50', quantity=6)
sell('Socks', price='$2.50', quantity=6)
sell('Socks', quantity=6, price='$2.50')
</pre>
<p class="cn" id="cn59">In Python regular expressions, the syntax for named regular expression groups is
<tt class="docutils literal"><span class="pre">(?P&lt;name&gt;pattern)</span></tt> , where <tt class="docutils literal"><span class="pre">name</span></tt> is the name of the group and <tt class="docutils literal"><span class="pre">pattern</span></tt> is some pattern to
match.</p>
<p class="cn" id="cn60">Heres an example URLconf that uses non-named groups:</p>
<pre class="cn literal-block" id="cn61">
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(\d{4})/$', views.year_archive),
    (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
)
</pre>
<p class="cn" id="cn63">Heres the same URLconf, rewritten to use named groups:</p>
<pre class="cn literal-block" id="cn64">
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(?P&lt;year&gt;\d{4})/$', views.year_archive),
    (r'^articles/(?P&lt;year&gt;\d{4})/(?P&lt;month&gt;\d{2})/$', views.month_archive),
)
</pre>
<p class="cn" id="cn66">This accomplishes exactly the same thing as the previous example, with one subtle difference: the
captured values are passed to view functions as keyword arguments rather than positional arguments.</p>
<p class="cn" id="cn67">For example, with non-named groups, a request to <tt class="docutils literal"><span class="pre">/articles/2006/03/</span></tt> would result in a function
call equivalent to this:</p>
<pre class="cn literal-block" id="cn68">
month_archive(request, '2006', '03')
</pre>
<p class="cn" id="cn70">With named groups, though, the same request would result in this function call:</p>
<pre class="cn literal-block" id="cn71">
month_archive(request, year='2006', month='03')
</pre>
<p class="cn" id="cn73">In practice, using named groups makes your URLconfs slightly more explicit and less prone to
argument-order bugs and you can reorder the arguments in your views function definitions. Following
the preceding example, if we wanted to change the URLs to include the month <em>before</em> the year, and
we were using non-named groups, wed have to remember to change the order of arguments in the
<tt class="docutils literal"><span class="pre">month_archive</span></tt> view. If we were using named groups, changing the order of the captured
parameters in the URL would have no effect on the view.</p>
<p class="cn" id="cn74">Of course, the benefits of named groups come at the cost of brevity; some developers find the
named-group syntax ugly and too verbose. Still, another advantage of named groups is readability,
especially by those who arent intimately familiar with regular expressions or your particular
Django application. Its easier to see whats happening, at a glance, in a URLconf that uses named
groups.</p>
</div>
<div class="section" id="understanding-the-matching-grouping-algorithm">
<span id="cn75"></span><h3 class="cn" id="cn75">Understanding the Matching/Grouping Algorithm</h3>
<p class="cn" id="cn76">A caveat with using named groups in a URLconf is that a single URLconf pattern cannot contain both
named and non-named groups. If you do this, Django wont throw any errors, but youll probably find
that your URLs arent matching as you expect. Specifically, heres the algorithm the URLconf parser
follows, with respect to named groups vs. non-named groups in a regular expression:</p>
<ul class="simple">
<li class="cn" id="cn77"><p class="first cn" id="cn77">If there are any named arguments, it will use those, ignoring non-named arguments.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn78"><p class="first cn" id="cn78">Otherwise, it will pass all non-named arguments as positional arguments.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn79"><p class="first cn" id="cn79">In both cases, it will pass any extra options as keyword arguments. See the next section for
more information.</p>
</li>
</ul>
</div>
<div class="section" id="passing-extra-options-to-view-functions">
<span id="cn80"></span><h3 class="cn" id="cn80">Passing Extra Options to View Functions</h3>
<p class="cn" id="cn81">Sometimes youll find yourself writing view functions that are quite similar, with only a few small
differences. For example, say you have two views whose contents are identical except for the
template they use:</p>
<pre class="cn literal-block" id="cn82">
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^foo/$', views.foo_view),
    (r'^bar/$', views.bar_view),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foo_view(request):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response('template1.html', {'m_list': m_list})

def bar_view(request):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response('template2.html', {'m_list': m_list})
</pre>
<p class="cn" id="cn84">Were repeating ourselves in this code, and thats inelegant. At first, you may think to remove the
redundancy by using the same view for both URLs, putting parentheses around the URL to capture it,
and checking the URL within the view to determine the template, like so:</p>
<pre class="cn literal-block" id="cn85">
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^(foo)/$', views.foobar_view),
    (r'^(bar)/$', views.foobar_view),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, url):
    m_list = MyModel.objects.filter(is_new=True)
    if url == 'foo':
        template_name = 'template1.html'
    elif url == 'bar':
        template_name = 'template2.html'
    return render_to_response(template_name, {'m_list': m_list})
</pre>
<p class="cn" id="cn87">The problem with that solution, though, is that it couples your URLs to your code. If you decide to
rename <tt class="docutils literal"><span class="pre">/foo/</span></tt> to <tt class="docutils literal"><span class="pre">/fooey/</span></tt> , youll have to remember to change the view code.</p>
<p class="cn" id="cn88">The elegant solution involves an optional URLconf parameter. Each pattern in a URLconf may include
a third item: a dictionary of keyword arguments to pass to the view function.</p>
<p class="cn" id="cn89">With this in mind, we can rewrite our ongoing example like this:</p>
<pre class="cn literal-block" id="cn90">
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
    (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, template_name):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response(template_name, {'m_list': m_list})
</pre>
<p class="cn" id="cn92">As you can see, the URLconf in this example specifies <tt class="docutils literal"><span class="pre">template_name</span></tt> in the URLconf. The view
function treats it as just another parameter.</p>
<p class="cn" id="cn93">This extra URLconf options technique is a nice way of sending additional information to your view
functions with minimal fuss. As such, its used by a couple of Djangos bundled applications, most
notably its generic views system, which we cover in Chapter 9.</p>
<p class="cn" id="cn94">The following sections contain a couple of ideas on how you can use the extra URLconf options
technique in your own projects.</p>
<div class="section" id="faking-captured-urlconf-values">
<span id="cn95"></span><h4 class="cn" id="cn95">Faking Captured URLconf Values</h4>
<p class="cn" id="cn96">Say you have a set of views that match a pattern, along with another URL that doesnt fit the
pattern but whose view logic is the same. In this case, you can fake the capturing of URL values by
using extra URLconf options to handle that extra URL with the same view.</p>
<p class="cn" id="cn97">For example, you might have an application that displays some data for a particular day, with URLs
such as these:</p>
<pre class="cn literal-block" id="cn98">
/mydata/jan/01/
/mydata/jan/02/
/mydata/jan/03/
# ...
/mydata/dec/30/
/mydata/dec/31/
</pre>
<p class="cn" id="cn100">This is simple enough to deal with you can capture those in a URLconf like this (using named group
syntax):</p>
<pre class="cn literal-block" id="cn101">
urlpatterns = patterns('',
    (r'^mydata/(?P&lt;month&gt;\w{3})/(?P&lt;day&gt;\d\d)/$', views.my_view),
)
</pre>
<p class="cn" id="cn103">And the view function signature would look like this:</p>
<pre class="cn literal-block" id="cn104">
def my_view(request, month, day):
    # ....
</pre>
<p class="cn" id="cn106">This approach is straightforward its nothing you havent seen before. The trick comes in when you
want to add another URL that uses <tt class="docutils literal"><span class="pre">my_view</span></tt> but whose URL doesnt include a <tt class="docutils literal"><span class="pre">month</span></tt> and/or
<tt class="docutils literal"><span class="pre">day</span></tt> .</p>
<p class="cn" id="cn107">For example, you might want to add another URL, <tt class="docutils literal"><span class="pre">/mydata/birthday/</span></tt> , which would be equivalent
to <tt class="docutils literal"><span class="pre">/mydata/jan/06/</span></tt> . You can take advantage of extra URLconf options like so:</p>
<pre class="cn literal-block" id="cn108">
urlpatterns = patterns('',
    (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
    (r'^mydata/(?P&lt;month&gt;\w{3})/(?P&lt;day&gt;\d\d)/$', views.my_view),
)
</pre>
<p class="cn" id="cn110">The cool thing here is that you dont have to change your view function at all. The view function
only cares that it <em>gets</em> <tt class="docutils literal"><span class="pre">month</span></tt> and <tt class="docutils literal"><span class="pre">day</span></tt> parameters it doesnt matter whether they come from
the URL capturing itself or extra parameters.</p>
</div>
<div class="section" id="making-a-view-generic">
<span id="cn111"></span><h4 class="cn" id="cn111">Making a View Generic</h4>
<p class="cn" id="cn112">Its good programming practice to factor out commonalities in code. For example, with these two
Python functions:</p>
<pre class="cn literal-block" id="cn113">
def say_hello(person_name):
    print 'Hello, %s' % person_name

def say_goodbye(person_name):
    print 'Goodbye, %s' % person_name
</pre>
<p class="cn" id="cn115">we can factor out the greeting to make it a parameter:</p>
<pre class="cn literal-block" id="cn116">
def greet(person_name, greeting):
    print '%s, %s' % (greeting, person_name)
</pre>
<p class="cn" id="cn118">You can apply this same philosophy to your Django views by using extra URLconf parameters.</p>
<p class="cn" id="cn119">With this in mind, you can start making higher-level abstractions of your views. Instead of
thinking to yourself, This view displays a list of <tt class="docutils literal"><span class="pre">Event</span></tt> objects, and That view displays a list
of <tt class="docutils literal"><span class="pre">BlogEntry</span></tt> objects, realize theyre both specific cases of A view that displays a list of
objects, where the type of object is variable.</p>
<p class="cn" id="cn120">Take this code, for example:</p>
<pre class="cn literal-block" id="cn121">
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^events/$', views.event_list),
    (r'^blog/entries/$', views.entry_list),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import Event, BlogEntry

def event_list(request):
    obj_list = Event.objects.all()
    return render_to_response('mysite/event_list.html', {'event_list': obj_list})

def entry_list(request):
    obj_list = BlogEntry.objects.all()
    return render_to_response('mysite/blogentry_list.html', {'entry_list': obj_list})
</pre>
<p class="cn" id="cn123">The two views do essentially the same thing: they display a list of objects. So lets factor out the
type of object theyre displaying:</p>
<pre class="cn literal-block" id="cn124">
# urls.py

from django.conf.urls.defaults import *
from mysite import models, views

urlpatterns = patterns('',
    (r'^events/$', views.object_list, {'model': models.Event}),
    (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
)

# views.py

from django.shortcuts import render_to_response

def object_list(request, model):
    obj_list = model.objects.all()
    template_name = 'mysite/%s_list.html' % model.__name__.lower()
    return render_to_response(template_name, {'object_list': obj_list})
</pre>
<p class="cn" id="cn126">With those small changes, we suddenly have a reusable, model-agnostic view! From now on, anytime we
need a view that lists a set of objects, we can simply reuse this <tt class="docutils literal"><span class="pre">object_list</span></tt> view rather than
writing view code. Here are a couple of notes about what we did:</p>
<ul class="simple">
<li class="cn" id="cn127"><p class="first cn" id="cn127">Were passing the model classes directly, as the <tt class="docutils literal"><span class="pre">model</span></tt> parameter. The dictionary of extra
URLconf options can pass any type of Python object not just strings.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn128"><p class="first cn" id="cn128">The <tt class="docutils literal"><span class="pre">model.objects.all()</span></tt> line is an example of <em>duck typing</em> : If it walks like a duck and
talks like a duck, we can treat it like a duck. Note the code doesnt know what type of object
<tt class="docutils literal"><span class="pre">model</span></tt> is; the only requirement is that <tt class="docutils literal"><span class="pre">model</span></tt> have an <tt class="docutils literal"><span class="pre">objects</span></tt> attribute, which in
turn has an <tt class="docutils literal"><span class="pre">all()</span></tt> method.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn129"><p class="first cn" id="cn129">Were using <tt class="docutils literal"><span class="pre">model.__name__.lower()</span></tt> in determining the template name. Every Python class has
a <tt class="docutils literal"><span class="pre">__name__</span></tt> attribute that returns the class name. This feature is useful at times like
this, when we dont know the type of class until runtime. For example, the <tt class="docutils literal"><span class="pre">BlogEntry</span></tt> classs
<tt class="docutils literal"><span class="pre">__name__</span></tt> is the string <tt class="docutils literal"><span class="pre">'BlogEntry'</span></tt> .</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn130"><p class="first cn" id="cn130">In a slight difference between this example and the previous example, were passing the generic
variable name <tt class="docutils literal"><span class="pre">object_list</span></tt> to the template. We could easily change this variable name to be
<tt class="docutils literal"><span class="pre">blogentry_list</span></tt> or <tt class="docutils literal"><span class="pre">event_list</span></tt> , but weve left that as an exercise for the reader.</p>
</li>
</ul>
<p class="cn" id="cn131">Because database-driven Web sites have several common patterns, Django comes with a set of generic
views that use this exact technique to save you time. We cover Djangos built-in generic views in
the next chapter.</p>
</div>
<div class="section" id="giving-a-view-configuration-options">
<span id="cn132"></span><h4 class="cn" id="cn132">Giving a View Configuration Options</h4>
<p class="cn" id="cn133">If youre distributing a Django application, chances are that your users will want some degree of
configuration. In this case, its a good idea to add hooks to your views for any configuration
options you think people may want to change. You can use extra URLconf parameters for this purpose.</p>
<p class="cn" id="cn134">A common bit of an application to make configurable is the template name:</p>
<pre class="cn literal-block" id="cn135">
def my_view(request, template_name):
    var = do_something()
    return render_to_response(template_name, {'var': var})
</pre>
</div>
<div class="section" id="understanding-precedence-of-captured-values-vs-extra-options">
<span id="cn137"></span><h4 class="cn" id="cn137">Understanding Precedence of Captured Values vs. Extra Options</h4>
<p class="cn" id="cn138">When theres a conflict, extra URLconf parameters get precedence over captured parameters. In other
words, if your URLconf captures a named-group variable and an extra URLconf parameter includes a
variable with the same name, the extra URLconf parameter value will be used.</p>
<p class="cn" id="cn139">For example, consider this URLconf:</p>
<pre class="cn literal-block" id="cn140">
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^mydata/(?P&lt;id&gt;\d+)/$', views.my_view, {'id': 3}),
)
</pre>
<p class="cn" id="cn142">Here, both the regular expression and the extra dictionary include an <tt class="docutils literal"><span class="pre">id</span></tt> . The hard-coded
<tt class="docutils literal"><span class="pre">id</span></tt> gets precedence. That means any request (e.g., <tt class="docutils literal"><span class="pre">/mydata/2/</span></tt> or <tt class="docutils literal"><span class="pre">/mydata/432432/</span></tt> ) will
be treated as if <tt class="docutils literal"><span class="pre">id</span></tt> is set to <tt class="docutils literal"><span class="pre">3</span></tt> , regardless of the value captured in the URL.</p>
<p class="cn" id="cn143">Astute readers will note that in this case, its a waste of time and typing to capture the <tt class="docutils literal"><span class="pre">id</span></tt> in
the regular expression, because its value will always be overridden by the dictionarys value. Thats
correct; we bring this up only to help you avoid making the mistake.</p>
</div>
</div>
<div class="section" id="using-default-view-arguments">
<span id="cn144"></span><h3 class="cn" id="cn144">Using Default View Arguments</h3>
<p class="cn" id="cn145">Another convenient trick is to specify default parameters for a views arguments. This tells the
view which value to use for a parameter by default if none is specified.</p>
<p class="cn" id="cn146">Heres an example:</p>
<pre class="cn literal-block" id="cn147">
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/$', views.page),
    (r'^blog/page(?P&lt;num&gt;\d+)/$', views.page),
)

# views.py

def page(request, num=&quot;1&quot;):
    # Output the appropriate page of blog entries, according to num.
    # ...
</pre>
<p class="cn" id="cn149">Here, both URL patterns point to the same view <tt class="docutils literal"><span class="pre">views.page</span></tt> but the first pattern doesnt capture
anything from the URL. If the first pattern matches, the <tt class="docutils literal"><span class="pre">page()</span></tt> function will use its default
argument for <tt class="docutils literal"><span class="pre">num</span></tt> , <tt class="docutils literal"><span class="pre">&quot;1&quot;</span></tt> . If the second pattern matches, <tt class="docutils literal"><span class="pre">page()</span></tt> will use whatever
<tt class="docutils literal"><span class="pre">num</span></tt> value was captured by the regular expression.</p>
<p class="cn" id="cn150">Its common to use this technique in conjunction with configuration options, as explained earlier.
This example makes a slight improvement to the example in the Giving a View Configuration Options
section by providing a default value for <tt class="docutils literal"><span class="pre">template_name</span></tt> :</p>
<pre class="cn literal-block" id="cn151">
def my_view(request, template_name='mysite/my_view.html'):
    var = do_something()
    return render_to_response(template_name, {'var': var})
</pre>
</div>
<div class="section" id="special-casing-views">
<span id="cn153"></span><h3 class="cn" id="cn153">Special-Casing Views</h3>
<p class="cn" id="cn154">Sometimes youll have a pattern in your URLconf that handles a large set of URLs, but youll need to
special-case one of them. In this case, take advantage of the linear way a URLconf is processed and
put the special case first.</p>
<p class="cn" id="cn155">For example, the add an object pages in Djangos admin site are represented by this URLconf line:</p>
<pre class="cn literal-block" id="cn156">
urlpatterns = patterns('',
    # ...
    ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
    # ...
)
</pre>
<p class="cn" id="cn158">This matches URLs such as <tt class="docutils literal"><span class="pre">/myblog/entries/add/</span></tt> and <tt class="docutils literal"><span class="pre">/auth/groups/add/</span></tt> . However, the add
page for a user object (<tt class="docutils literal"><span class="pre">/auth/user/add/</span></tt> ) is a special case it doesnt display all of the form
fields, it displays two password fields, and so forth. We <em>could</em> solve this problem by
special-casing in the view, like so:</p>
<pre class="cn literal-block" id="cn159">
def add_stage(request, app_label, model_name):
    if app_label == 'auth' and model_name == 'user':
        # do special-case code
    else:
        # do normal code
</pre>
<p class="cn" id="cn161">but thats inelegant for a reason weve touched on multiple times in this chapter: it puts URL logic
in the view. As a more elegant solution, we can take advantage of the fact that URLconfs are
processed in order from top to bottom:</p>
<pre class="cn literal-block" id="cn162">
urlpatterns = patterns('',
    # ...
    ('^auth/user/add/$', 'django.contrib.admin.views.auth.user_add_stage'),
    ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
    # ...
)
</pre>
<p class="cn" id="cn164">With this in place, a request to <tt class="docutils literal"><span class="pre">/auth/user/add/</span></tt> will be handled by the <tt class="docutils literal"><span class="pre">user_add_stage</span></tt>
view. Although that URL matches the second pattern, it matches the top one first. (This is
short-circuit logic.)</p>
</div>
<div class="section" id="capturing-text-in-urls">
<span id="cn165"></span><h3 class="cn" id="cn165">Capturing Text in URLs</h3>
<p class="cn" id="cn166">Each captured argument is sent to the view as a plain Python string, regardless of what sort of
match the regular expression makes. For example, in this URLconf line:</p>
<pre class="cn literal-block" id="cn167">
(r'^articles/(?P&lt;year&gt;\d{4})/$', views.year_archive),
</pre>
<p class="cn" id="cn169">the <tt class="docutils literal"><span class="pre">year</span></tt> argument to <tt class="docutils literal"><span class="pre">views.year_archive()</span></tt> will be a string, not an integer, even though
<tt class="docutils literal"><span class="pre">\d{4}</span></tt> will only match integer strings.</p>
<p class="cn" id="cn170">This is important to keep in mind when youre writing view code. Many built-in Python functions are
fussy (and rightfully so) about accepting only objects of a certain type. A common error is to
attempt to create a <tt class="docutils literal"><span class="pre">datetime.date</span></tt> object with string values instead of integer values:</p>
<pre class="cn literal-block" id="cn171">
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.date('1993', '7', '9')
Traceback (most recent call last):
    ...
TypeError: an integer is required
&gt;&gt;&gt; datetime.date(1993, 7, 9)
datetime.date(1993, 7, 9)
</pre>
<p class="cn" id="cn173">Translated to a URLconf and view, the error looks like this:</p>
<pre class="cn literal-block" id="cn174">
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^articles/(\d{4})/(\d{2})/(\d{2})/$', views.day_archive),
)

# views.py

import datetime

def day_archive(request, year, month, day)
    # The following statement raises a TypeError!
    date = datetime.date(year, month, day)
</pre>
<p class="cn" id="cn176">Instead, <tt class="docutils literal"><span class="pre">day_archive()</span></tt> can be written correctly like this:</p>
<pre class="cn literal-block" id="cn177">
def day_archive(request, year, month, day)
    date = datetime.date(int(year), int(month), int(day))
</pre>
<p class="cn" id="cn179">Note that <tt class="docutils literal"><span class="pre">int()</span></tt> itself raises a <tt class="docutils literal"><span class="pre">ValueError</span></tt> when you pass it a string that is not composed
solely of digits, but were avoiding that error in this case because the regular expression in our
URLconf has ensured that only strings containing digits are passed to the view function.</p>
</div>
<div class="section" id="determining-what-the-urlconf-searches-against">
<span id="cn180"></span><h3 class="cn" id="cn180">Determining What the URLconf Searches Against</h3>
<p class="cn" id="cn181">When a request comes in, Django tries to match the URLconf patterns against the requested URL, as a
normal Python string (not as a Unicode string). This does not include <tt class="docutils literal"><span class="pre">GET</span></tt> or <tt class="docutils literal"><span class="pre">POST</span></tt>
parameters, or the domain name. It also does not include the leading slash, because every URL has a
leading slash.</p>
<p class="cn" id="cn182">For example, in a request to <tt class="docutils literal"><span class="pre">http://www.example.com/myapp/</span></tt> , Django will try to match
<tt class="docutils literal"><span class="pre">myapp/</span></tt> . In a request to <tt class="docutils literal"><span class="pre">http://www.example.com/myapp/?page=3</span></tt> , Django will try to match
<tt class="docutils literal"><span class="pre">myapp/</span></tt> .</p>
<p class="cn" id="cn183">The request method (e.g., <tt class="docutils literal"><span class="pre">POST</span></tt> , <tt class="docutils literal"><span class="pre">GET</span></tt> , <tt class="docutils literal"><span class="pre">HEAD</span></tt> ) is <em>not</em> taken into account when
traversing the URLconf. In other words, all request methods will be routed to the same function for
the same URL. Its the responsibility of a view function to perform branching based on request
method.</p>
</div>
</div>
<div class="section" id="including-other-urlconfs">
<span id="cn184"></span><h2 class="cn" id="cn184">Including Other URLconfs</h2>
<p class="cn" id="cn185">If you intend your code to be used on multiple Django-based sites, you should consider arranging
your URLconfs in such a way that allows for including.</p>
<p class="cn" id="cn186">At any point, your URLconf can include other URLconf modules. This essentially roots a set of URLs
below other ones. For example, this URLconf includes other URLconfs:</p>
<pre class="cn literal-block" id="cn187">
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^weblog/', include('mysite.blog.urls')),
    (r'^photos/', include('mysite.photos.urls')),
    (r'^about/$', 'mysite.views.about'),
)
</pre>
<p class="cn" id="cn189">Theres an important gotcha here: the regular expressions in this example that point to an
<tt class="docutils literal"><span class="pre">include()</span></tt> do <em>not</em> have a <tt class="docutils literal"><span class="pre">$</span></tt> (end-of-string match character) but <em>do</em> include a trailing
slash. Whenever Django encounters <tt class="docutils literal"><span class="pre">include()</span></tt> , it chops off whatever part of the URL matched up
to that point and sends the remaining string to the included URLconf for further processing.</p>
<p class="cn" id="cn190">Continuing this example, heres the URLconf <tt class="docutils literal"><span class="pre">mysite.blog.urls</span></tt> :</p>
<pre class="cn literal-block" id="cn191">
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(\d\d\d\d)/$', 'mysite.blog.views.year_detail'),
    (r'^(\d\d\d\d)/(\d\d)/$', 'mysite.blog.views.month_detail'),
)
</pre>
<p class="cn" id="cn193">With these two URLconfs, heres how a few sample requests would be handled:</p>
<ul class="simple">
<li class="cn" id="cn194"><p class="first cn" id="cn194"><tt class="docutils literal"><span class="pre">/weblog/2007/</span></tt> : In the first URLconf, the pattern <tt class="docutils literal"><span class="pre">r'^weblog/'</span></tt> matches. Because it is an
<tt class="docutils literal"><span class="pre">include()</span></tt> , Django strips all the matching text, which is <tt class="docutils literal"><span class="pre">'weblog/'</span></tt> in this case. The
remaining part of the URL is <tt class="docutils literal"><span class="pre">2007/</span></tt> , which matches the first line in the
<tt class="docutils literal"><span class="pre">mysite.blog.urls</span></tt> URLconf.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn195"><p class="first cn" id="cn195"><tt class="docutils literal"><span class="pre">/weblog//2007/</span></tt> : In the first URLconf, the pattern <tt class="docutils literal"><span class="pre">r'^weblog/'</span></tt> matches. Because it is
an <tt class="docutils literal"><span class="pre">include()</span></tt> , Django strips all the matching text, which is <tt class="docutils literal"><span class="pre">'weblog/'</span></tt> in this case.
The remaining part of the URL is <tt class="docutils literal"><span class="pre">/2007/</span></tt> (with a leading slash), which does not match any of
the lines in the <tt class="docutils literal"><span class="pre">mysite.blog.urls</span></tt> URLconf.</p>
</li>
</ul>
<ul class="simple">
<li class="cn" id="cn196"><p class="first cn" id="cn196"><tt class="docutils literal"><span class="pre">/about/</span></tt> : This matches the view <tt class="docutils literal"><span class="pre">mysite.views.about</span></tt> in the first URLconf, demonstrating
that you can mix <tt class="docutils literal"><span class="pre">include()</span></tt> patterns with non-<tt class="docutils literal"><span class="pre">include()</span></tt> patterns.</p>
</li>
</ul>
<div class="section" id="how-captured-parameters-work-with-include">
<span id="cn197"></span><h3 class="cn" id="cn197">How Captured Parameters Work with include()</h3>
<p class="cn" id="cn198">An included URLconf receives any captured parameters from parent URLconfs, for example:</p>
<pre class="cn literal-block" id="cn199">
# root urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(?P&lt;username&gt;\w+)/blog/', include('foo.urls.blog')),
)

# foo/urls/blog.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^$', 'foo.views.blog_index'),
    (r'^archive/$', 'foo.views.blog_archive'),
)
</pre>
<p class="cn" id="cn201">In this example, the captured <tt class="docutils literal"><span class="pre">username</span></tt> variable is passed to the included URLconf and, hence,
to <em>every</em> view function within that URLconf.</p>
<p class="cn" id="cn202">Note that the captured parameters will <em>always</em> be passed to <em>every</em> line in the included URLconf,
regardless of whether the lines view actually accepts those parameters as valid. For this reason,
this technique is useful only if youre certain that every view in the included URLconf accepts the
parameters youre passing.</p>
</div>
<div class="section" id="how-extra-urlconf-options-work-with-include">
<span id="cn203"></span><h3 class="cn" id="cn203">How Extra URLconf Options Work with include()</h3>
<p class="cn" id="cn204">Similarly, you can pass extra URLconf options to <tt class="docutils literal"><span class="pre">include()</span></tt> , just as you can pass extra URLconf
options to a normal view as a dictionary. When you do this, <em>each</em> line in the included URLconf
will be passed the extra options.</p>
<p class="cn" id="cn205">For example, the following two URLconf sets are functionally identical.</p>
<p class="cn" id="cn206">Set one:</p>
<pre class="cn literal-block" id="cn207">
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/', include('inner'), {'blogid': 3}),
)

# inner.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^archive/$', 'mysite.views.archive'),
    (r'^about/$', 'mysite.views.about'),
    (r'^rss/$', 'mysite.views.rss'),
)
</pre>
<p class="cn" id="cn209">Set two:</p>
<pre class="cn literal-block" id="cn210">
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/', include('inner')),
)

# inner.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
    (r'^about/$', 'mysite.views.about', {'blogid': 3}),
    (r'^rss/$', 'mysite.views.rss', {'blogid': 3}),
)
</pre>
<p class="cn" id="cn212">As is the case with captured parameters (explained in the previous section), extra options will
<em>always</em> be passed to <em>every</em> line in the included URLconf, regardless of whether the lines view
actually accepts those options as valid. For this reason, this technique is useful only if youre
certain that every view in the included URLconf accepts the extra options youre passing.</p>
</div>
</div>
<div class="section" id="whats-next">
<span id="cn213"></span><h2 class="cn" id="cn213">Whats Next?</h2>
<p class="cn" id="cn214">One of Djangos main goals is to reduce the amount of code developers need to write, and in this
chapter we suggested how to cut down the code of your views and URLconfs.</p>
<p class="cn" id="cn215">The next logical step in code elimination is removing the need to write views entirely. Thats the
topic of the next chapter.</p>
</div>
</div>

    
    </div>
  </div>
</div>
</div>
<div id="ft">
        <div class="nav">
	<a href="/chapter08/ecn/">| 中英文对照</a> |
	<a href="/chapter08/en/">英文</a> |
	<a href="/chapter08/">中文</a>
	<a href="/chapter07/en/">| 上一章</a> |
	<a href="/">目  录</a> |
	<a href="/chapter09/en/">下一章 </a> |
	<a href="/chapter08/translate/">翻译 </a>  |
</div>

</div>
</div>
<div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div>
<!-- comment dialog -->
<div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned">
    <div class="hd" id="djangobookcomments-head">
      Comments <span class="close" onclick="Comments.close();">X</span>
    </div>
    <div class="bd">
        <div id="comment-tabs">
            <!-- comment form -->
            <div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody">
              <form action="comments/" method="post" id="commentform">
                <p>
                  <input name="nodenum" value="" type="hidden">
                  <label for="id_name">姓名 (必填)</label>
                  <input name="name" id="id_name" value="" tabindex="1" type="text">
                </p>
                <p>
                  <label for="id_email">E-mail (必填; 不会显示)</label>
                  <input name="email" id="id_email" value="" tabindex="2" type="text">
                </p>
                <p>
                  <label for="id_url">网站</label>
                  <input name="url" id="id_url" value="" tabindex="3" type="text">
                </p>
                <p>
                  <label for="id_comment">评注</label>
                  <textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea>
                </p>
              </form>
            </div>
            <!-- comments on this node tab: filled in dynamically -->
            <div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody">
              <ol id="current-comments-list"></ol>
            </div>
            <!-- all comments tab: also dynamic -->
            <div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody">
              <ol id="all-comments-list"></ol>
            </div>
            <!-- help -->
            <div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody">
              <h4>关于本评注系统</h4>
              <p>
                本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，
                我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：
              </p>
              <p class="image">
                <img src="/sitemedia/comments1.png" height="100" width="350">
              </p>
              <p>
                一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。
                你选中它会高亮度显示:
              </p>
              <p class="image">
                <img src="/sitemedia/comments2.png" height="100" width="350">
              </p>
              <p>
                要对文本块做评注，你只需要点击它旁边的标识块:
              </p>
              <p class="image">
                <img src="/sitemedia/comments3.png" height="100" width="350">
              </p>
              <p>
                我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:
              </p>
              <p>
                如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）
              </p>
              <p class="image">
                <img src="/sitemedia/comments4.png" height="100" width="350">
              </p>
              <p>
                Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;
                the inspiration and much of the code for the comment system comes from Jack's
                blog, and this site couldn't have been built without his wonderful 
                <code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.
              </p>
            </div>
        </div>
    </div>
    <div class="ft">
       <div style="visibility: hidden;" class="" id="djangobookcomments-message"></div>
       <div id="comments-submit-wrapper">
        <input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button">
        <input id="comment-close" value="关闭" onclick="Comments.close();" type="button">
      </div>
    </div>
</div>
<!-- translation dialog -->
<div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned">
    <div class="hd" id="djangobooktranslations-head">
      Translations <span class="close" onclick="Translations.close();">X</span>
    </div>
    <div class="bd">
        <div id="translation-tabs">
            <!-- comment form -->
            <div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody">
              <form action="translations/" method="post" id="translationform">
              </form>
            </div>
            <!-- comments on this node tab: filled in dynamically -->
            <div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody">
              <ol id="current-translations-list"></ol>
            </div>
	    <!-- settings -->
	    <div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody">
              
            </div>
            <!-- help -->
            <div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">
                帮助
            </div>
        </div>

    </div>
    <div class="ft">
        <div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div>
        <div id="translations-submit-wrapper">
            <input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button">
	    <input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button">
	    <input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button">
	    <input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button">
            <input id="translation-close" value="关闭" onclick="Translations.close();" type="button">
        </div>
    </div>
</div> <!-- end translation dialog -->

<div id="ft">
        
        Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>This
        work is licensed under the <a href="http://new.djangobook.com/license/">GNU Free Document
        License</a>.
        <br/>
        Hosting graciously provided by <a href="http://mediatemple.net/">
        <img style="vertical-align: middle; position: relative; top: -1px;" src="/sitemedia/mt.png" alt="media temple"></a>
        <br/>
        Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.
</div>
<script type="text/javascript" src="/sitemedia/css/djangobook.js"></script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-794487-4");
pageTracker._initData();
pageTracker._trackPageview();
</script>

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fb72113a7702cfc915d773f5432b147cf' type='text/javascript'%3E%3C/script%3E"));
</script>

</body>
</html>
